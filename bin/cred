#!/usr/bin/env python

__author__ = "Max Parmer <maxp@pdx.edu>"
__copyright__ = "Copyright 2011"
__credits__ = [
                "Max Parmer",
                "Elliot Schlegelmilch",
              ]
__license__ = "GPL"
__maintainer__ = "Max Parmer"
__email__ = "maxp@pdx.edu"
__status__ = "Development"

import argparse
import gnupg
import getpass
import glob
import os, errno
import sys
import yaml

from sets import Set

class Creds(object):
    def __init__(self, config=False, verbose=False):
        # force a sane default umask
        os.umask(0077)

        self.verbose = verbose
        
        if not config:
            config = os.path.expanduser("~") + "/.credconf.yaml"
        config_keys = self.load_yaml(self.__open(config, "r"))
 
        self.check_config(config_keys)

        # ensure the encrypting user is always in the recipient list
        config_keys['default_recipients'].append(config_keys['default_key'])
        # ensure credentials is an absolute path
        config_keys['credentials'] = os.path.abspath(config_keys['credentials'])
 
        # copy all the config keys into self
        self.__dict__.update(config_keys)
 
        # checking the veracity of the config
        # does the passwords, dir exist? do we have perms?
        self.__ensure_path(self.credentials)

        # check to see if there's actually an agent in the env
        self.agent = os.environ.get("GPG_AGENT_INFO", False)

        # wanting to use an agent is cool, but if you don't have one...
        if not self.agent or not self.use_agent:
            # whether this is the setting or the fallback, it's definitely False henceforth
            self.use_agent = False

        self.gpg = gnupg.GPG(gnupghome=self.gpg_home, use_agent=self.use_agent, verbose=self.verbose)

    def __open(self, path, mode):
        try:
            self.__v("Opening: %s, %s" % (path, mode))
            stream = open(path, mode)
        except IOError as err:
            raise Exception(err.strerror, err.filename)
        else:
            return stream
    
    def __ensure_path(self, path):
        requested_path = os.path.abspath(path)
        prefix = os.path.commonprefix([requested_path, self.credentials])
        # constrain the whole operation to subpaths of the configured credential directory
        if prefix != self.credentials:
            message = 'the requested path: \n\t %s\nis outside the configured credential directory:\n\t%s' % (requested_path, self.credentials)
            raise Exception('Path error', message)
        try:
            os.makedirs(path)
        except OSError as err:
            if err.errno != errno.EEXIST:
                raise
        else:
            sys.stderr.write("Creating the nonexistant %s.\n" % path)
        

    def __cryptwrap(self, fn, cred, *args, **kwargs):
        # clone the method from the gpg class
        self.__v("Trying method: %s on: %s" % (fn, cred))
        method = getattr(self.gpg, fn)
        if not self.use_agent:
            if not hasattr(self, "passphrase"):
                self.__v("Prompting for password.")
                self.passphrase = getpass.getpass()
            kwargs['passphrase'] = self.passphrase 

        cred = method(cred, *args, **kwargs)

        if cred.ok:
            return cred
        else:
            """
            I should eventually handle some of the recoverable cases.
            Potential values of cred.status are:
                'signature bad'
                'signature good'
                'signature valid'
                'signature error'
                'no public key'
                'need symmetric passphrase'
                'decryption incomplete'
                'encryption incomplete'
                'decryption ok'
                'encryption ok'
                'invalid recipient'
                'key expired'
                'sig created'
                'sig expired'
                'need passphrase'
            """
            raise Exception("%s failed" % fn, cred.status)
            
    def __decrypt(self, cred, *args, **kwargs):
        # TODO: implement signature verification
        return self.__cryptwrap('decrypt_file', cred, *args, **kwargs)

    def __encrypt(self, cred, *args, **kwargs):
        if self.sign:
            kwargs['sign'] = self.default_key
        return self.__cryptwrap('encrypt', cred, *args, **kwargs)

    def __v(self, message):
        if self.verbose:
            sys.stderr.write('\033[93m [CRED] \033[0m %s\n' % message)

    def check_config(self, config):
        required_keys = [
                            "credentials",
                            "default_key",
                            "default_recipients",
                            "extension",
                            "gpg_home",
                            "sign",
                            "use_agent",
                        ]
        config_keys = config.keys()
        config_keys.sort()
        if config_keys != required_keys:
            missing_set = Set(required_keys) - Set(config.keys())
            excess_set = Set(config.keys()) - Set(required_keys)
            for key in missing_set:
                sys.stderr.write("Missing config key: %s\n" % key)
            if excess_set:
                for excess_parameter in excess_set:
                    self.__v("Excess parameter in config: %s" % excess_parameter)
            else:
                raise Exception("Incomplete configuration", "the configuration was missing %d key(s)." % len(missing_set))

    def mod(self, cred):
        orig_cred = self.get(cred)
        orig_cred_keys = orig_cred.keys()
        prompt_defaults = ", ".join(orig_cred_keys)

        response = self.__prompt("Modify", prompt_defaults)
        mod_keys = response.split(",")

        # aggregate new and modified keys
        new_cred = []
        for key in mod_keys:
            key = key.strip()
            value = orig_cred.get(key, False)
            new_val = self.__prompt(key, value)
            new_cred.append("%s: %s" % (key, new_val))

        # copy unchanged keys from the orig_cred
        for key in orig_cred_keys:
            if key not in mod_keys:
                new_cred.append("%s: %s" % (key, orig_cred[key]))
        
        return self.save(cred, new_cred)

    def __prompt(self, query, default=False):
        prompt = "%s: " % query
        if default:
            prompt += "[%s] " % default
        response = raw_input(prompt)
        if not response:
            self.__v("asked for %s got %s" % (query, default))
            return default
        else:
            self.__v("asked for %s got %s" % (query, response))
            return response

    def add(self, cred):
        path = self.get_path(cred)

        if os.path.exists(path):
            raise Exception("Credential exists", "try `cred mod %s`" % cred)
        
        prompt_defaults = ", ".join(['username', 'password'])

        response = self.__prompt("Add which keys?", prompt_defaults)
        new_keys = response.split(",")

        # aggregate new and modified keys
        new_cred = []
        for key in new_keys:
            key = key.strip()
            new_val = self.__prompt(key)
            new_cred.append("%s: %s" % (key, new_val))

        return self.save(cred, new_cred)

    def save(self, cred, new_cred):
        path = self.get_path(cred)
        with self.__open(path, "wb") as new_cred_file:
            self.__v("Saving cred: $s..." % path)
            new_cred = "\n".join(new_cred)
            encrypted_cred = self.__encrypt(new_cred, self.default_recipients)
            new_cred_file.write(str(encrypted_cred))
            new_cred_file.flush()

        return self.get(cred)

    def get_path(self, cred):
        path = os.path.join(self.credentials, cred + self.extension)
        # strip any file names from the path
        parent_path = os.path.dirname(path)
        self.__ensure_path(parent_path)
        return path
    
    def get(self, cred):
        path = self.get_path(cred)
        with self.__open(path, "rb") as encrypted_file:
            decrypted = self.__decrypt(encrypted_file)

        return self.load_yaml(str(decrypted))

    def list_credentials(self, namespace=False):
        pattern = "*" + self.extension
        if namespace:
            list_path = os.path.join(self.credentials, namespace, pattern)
        else:
            list_path = os.path.join(self.credentials, pattern)
        return [cred.replace(self.extension, "") for cred in glob.glob(list_path)]

    def list_namespaces(self):
        return [namespace for namespace in os.listdir(self.credentials) if os.path.isdir(os.path.join(self.credentials, namespace))]

    def load_yaml(self, data):
        try:
            data = yaml.load(data)
        except yaml.YAMLError as err:
            # surpress most of YAMLError to avoid sending a stacktrace with a password to stderr
            raise Exception(err.context, err.problem)
        else:
            return data

class CredsArgParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write('error: %s\n' % message)
        self.print_help()
        sys.exit(2)

def add_cred(args):
    creds = cred_setup(args)
    new_cred = yaml.dump(creds.add(args.name), default_flow_style=False)
    print "\n\nSaved cred is..."
    print new_cred
    return 0

def get_cred(args):
    creds = cred_setup(args)
    if args.name:
        cred = creds.get(args.name)
        if args.fields:
            for field in args.fields:
                print cred.get(field)
        elif args.list_keys:
            for field in cred:
                print field
        else:
            print yaml.dump(cred, default_flow_style=False)
    else:
        cred_list = creds.list_credentials()
        for namespace in creds.list_namespaces():
            sub_creds = [os.path.join(namespace, cred) for cred in creds.list_credentials(namespace)]
            cred_list.extend(sub_creds)
        for cred in cred_list:
            # relpath because relpath is how you'll refer to them
            print os.path.relpath(cred, creds.credentials)
    return 0

def mod_cred(args):
    creds = cred_setup(args)
    changed_cred = yaml.dump(creds.mod(args.name), default_flow_style=False)
    print "\n\nChanged cred is..."
    print changed_cred
    return 0

def cred_setup(args):
    return Creds(
        config=args.config,
        verbose=args.verbose,
        )

def main():
    parser = CredsArgParser(description="Query passwords from GPG encrypted files.")

    parser.add_argument('-c', '--config', dest='config', default=False,
        help="An alternate configuration path. Default: ~/.credconf.yaml")
    parser.add_argument('-v', '--verbose', dest='verbose', default=False,
        action='store_true', help="Verbose")

    subparsers = parser.add_subparsers(help='Verbs for cred manipulation.')

    add_parser = subparsers.add_parser('add', help='Add a credential or add a key to a credential.')
    add_parser.add_argument('name', nargs="?", help="The name of the credential to add, i.e. example.com")
    add_parser.set_defaults(func=add_cred)

    get_parser = subparsers.add_parser('get', help='Get credential contents or credential keys.')
    get_parser.add_argument('-k', '--keys', dest='list_keys', action='store_true', help='List only the keys in a credential.')
    get_parser.add_argument('name', nargs="?", default=False,
        help="The name of the credential to get contents of. If no name is specified, lists all credentials.")
    get_parser.add_argument('fields', default=False, nargs="*",
        help="The name of the field or fields to get. If no fields are specified, all fields are returned.")
    get_parser.set_defaults(func=get_cred)

    mod_parser = subparsers.add_parser('modify', help='Modify an existing credential.')
    mod_parser.add_argument('name', nargs='?', help="The name of the credential to modify.")
    mod_parser.set_defaults(func=mod_cred)

    args = parser.parse_args()

    try:
        return args.func(args)
    except Exception as (errno, strerr):
        sys.stderr.write('%s: %s\n' % (errno, strerr))
        return 1

if __name__ == "__main__":
    sys.exit(main())
