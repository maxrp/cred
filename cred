#!/usr/bin/env python

import argparse
import gnupg
import getpass
import os, errno
import sys
import yaml

class Creds(object):
    def __init__(self, config=False, verbose=False):
        if not config:
            config = os.path.expanduser("~") + "/.credconf.yaml"
        config_keys = self.load_yaml(self.__open(config, "r"))
        
        self.check_config(config_keys)

        # copy all the config keys into self
        for key in config_keys:
            self.__dict__[key] = config_keys[key]
 
        # checking the veracity of the config
        # does the passwords, dir exist? do we have perms?
        try:
            os.makedirs(self.credentials, 0700)
        except OSError as err:
            if err.errno != errno.EEXIST:
                raise
        else:
            sys.stderr.write("Creating the nonexistant %s as per %s.\n" % (self.credentials, config))

        if not self.default_recipients:
            raise Exception("No default recipients", "this tool only supports asymmetric encryption at present.")

        # check to see if there's actually an agent in the env
        self.agent = os.environ.get("GPG_AGENT_INFO", False)
        self.verbose = verbose

        # wanting to use an agent is cool, but if you don't have one...
        if not self.agent or not self.use_agent:
            # whether this is the setting or the fallback, it's definitely False henceforth
            self.use_agent = False

        self.gpg = gnupg.GPG(gnupghome=self.gpg_home, use_agent=self.use_agent, verbose=self.verbose)

    def __open(self, path, mode):
        try:
            stream = open(path, mode)
        except IOError as err:
            raise Exception(err.strerror, err.filename)
        else:
            return stream
    
    def __cryptwrap(self, fn, cred, *args, **kwargs):
        method = getattr(self.gpg, fn)
        if not self.use_agent:
            if not hasattr(self, "passphrase"):
                self.passphrase = getpass.getpass()
            cred = method(cred, *args, passphrase=self.passphrase, **kwargs)
        else:
            cred = method(cred, *args, **kwargs)

        if cred.ok:
            return cred
        else:
            """
            I should eventually handle some of the recoverable cases.
            Potential values of cred.status are:
                'signature bad'
                'signature good'
                'signature valid'
                'signature error'
                'no public key'
                'need symmetric passphrase'
                'decryption incomplete'
                'encryption incomplete'
                'decryption ok'
                'encryption ok'
                'invalid recipient'
                'key expired'
                'sig created'
                'sig expired'
                'need passphrase'
            """
            raise Exception("%s failed" % fn, cred.status)
            
    def __decrypt(self, cred, *args, **kwargs):
        return self.__cryptwrap('decrypt_file', cred, *args, **kwargs)

    def __encrypt(self, cred, *args, **kwargs):
        return self.__cryptwrap('encrypt', cred, *args, **kwargs)

    def check_config(self, config):
        required_keys = [
                            "schema",
                            "use_agent",
                            "gpg_home",
                            "credentials",
                            "extension",
                            "default_recipients",
                        ]
        if config.keys() != required_keys:
            from sets import Set
            missing_set = Set(required_keys) - Set(config.keys())
            for key in missing_set:
                sys.stderr.write("Missing config key: %s\n" % key)
            raise Exception("Incomplete configuration", "the configuration was missing %d key(s)." % len(missing_set))

    def save(self, cred):
        path = self.get_path(cred)

        # TODO: implement a prompt system accommodating existing creds
        # normally one would just want to try opening the file to avoid a race, but this is just to warn
        if os.path.exists(path):
            response = raw_input("WARNING: existing credentials in %s will be crushed! Continue? [y/n]" % path)
            if response is not "y":
                raise Exception("Credential exists", "the user does not wish to overwrite it.")

        with self.__open(path, "wb") as new_cred_file:
            print "Saving %s, prompting for details...\n" % cred
            print "Type a lone . to quit and save."

            new_cred = []

            # for complex schemas this will fail
            for key in self.schema:
                prompt = "%s: " % key
                entry = "%s: %s\n" % (key, raw_input(prompt))
                new_cred.append(entry)

            # give the user a chance to improvise
            entry = raw_input("")

            # additional chances for improvisation
            while entry is not ".":
                new_cred.append(entry + "\n")
                entry = raw_input("")

            new_cred = "".join(new_cred)
            encrypted_cred = self.__encrypt(new_cred, self.default_recipients)
            new_cred_file.write(str(encrypted_cred))
            new_cred_file.flush()

        return self.get(cred)

    def get_path(self, cred):
        return os.path.join(self.credentials, cred + self.extension)
    
    def get(self, cred):
        path = self.get_path(cred)
        with self.__open(path, "rb") as encrypted_file:
            decrypted = self.__decrypt(encrypted_file)

        return self.load_yaml(str(decrypted))

    def list_credentials(self):
       return [cred.replace(self.extension, "") for cred in os.listdir(self.credentials)]

    def load_yaml(self, data):
        try:
            data = yaml.load(data)
        except yaml.YAMLError as err:
            # surpress most of YAMLError to avoid sending a stacktrace with a password to stderr
            raise Exception(err.context, err.problem)
        else:
            return data

    def dump_schema(self):
        return yaml.dump(self.schema, default_flow_style=False)

def add_cred(args):
    creds = cred_setup(args)
    new_cred = yaml.dump(creds.save(args.name), default_flow_style=False)
    print "\n\nSaved cred is..."
    print new_cred
    return 0

def get_cred(args):
    creds = cred_setup(args)
    if args.name:
        cred = creds.get(args.name)
        if args.fields:
            for field in args.fields:
                print cred.get(field)
        elif args.list_keys:
            for field in cred:
                print field
        else:
            print yaml.dump(cred, default_flow_style=False)
    else:
        for cred in creds.list_credentials():
            print cred
    return 0

def cred_schema(args):
    creds = cred_setup(args)
    print creds.dump_schema()
    return 0

def cred_setup(args):
    if hasattr(args, 'config'):
        return Creds(config=args.config)
    else:
        return Creds()

def main():
    parser = argparse.ArgumentParser(description="Query passwords from GPG encrypted files.")

    parser.add_argument('-c', '--config', dest='config', default=False,
        help="An alternate configuration path. Default: ~/.credconf.yaml")

    subparsers = parser.add_subparsers(help='Verbs for cred manipulation.')

    add_parser = subparsers.add_parser('add', help='Add a credential or add a key to a credential.')
    add_parser.add_argument('name', nargs="?", help="The name of the credential to add, i.e. example.com")
    add_parser.set_defaults(func=add_cred)

    get_parser = subparsers.add_parser('get', help='Get credential contents or credential keys.')
    get_parser.add_argument('-k', '--keys', dest='list_keys', action='store_true', help='List only the keys in a credential.')
    get_parser.add_argument('name', nargs="?", default=False,
        help="The name of the credential to get contents of. If no name is specified, lists all credentials.")
    get_parser.add_argument('fields', default=False, nargs="*",
        help="The name of the field or fields to get. If no fields are specified, all fields are returned.")
    get_parser.set_defaults(func=get_cred)

    schema_parser = subparsers.add_parser('schema', help="Dump the schema from the loaded config.")
    schema_parser.set_defaults(func=cred_schema)

    args = parser.parse_args()

    try:
        return args.func(args)
    except Exception as (errno, strerr):
        sys.stderr.write('%s: %s\n' % (errno, strerr))
        return 1

if __name__ == "__main__":
    sys.exit(main())
