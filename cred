#!/usr/bin/env python

import argparse
import gnupg
import getpass
import os
import sys
import yaml

class Creds(object):
    def __init__(self, config="conf.yaml", verbose=False):
        config = self.load_yaml(self.__open(config, "r"))
        
        # copy all the config keys into self
        for attr in config:
            self.__dict__[attr] = config[attr]

        # check to see if there's actually an agent in the env
        self.agent = os.environ.get("GPG_AGENT_INFO", False)
        self.verbose = verbose

        # wanting to use an agent is cool, but if you don't have one...
        if not self.agent or not self.use_agent:
            # whether this is the setting or the fallback, it's definitely False henceforth
            self.use_agent = False
            self.passphrase = getpass.getpass()
        
        self.gpg = gnupg.GPG(gnupghome=self.gpg_home, use_agent=self.use_agent, verbose=self.verbose)

    def __open(self, path, mode):
        try:
            stream = open(path, mode)
        except IOError as err:
            raise Exception(err.strerror, err.filename)
        else:
            return stream        

    def save(self, cred):
        path = self.get_path(cred)
        
        # TODO: implement a prompt system accommodating existing creds
        # normally one would just want to try opening the file to avoid a race, but this is just to warn
        if os.path.exists(path):
            response = raw_input("WARNING: existing credentials in %s will be crushed! Continue? [y/n]" % path)
            if response is not "y":
                raise Exception("Credential exists", "the user does not wish to overwrite it.")

        new_cred_file = self.__open(path, "wb")

        print "Saving %s, prompting for details...\n" % cred
        print "Type a lone . to quit and save."
        
        new_cred = []
        
        # for complex schemas this will fail
        for key in self.schema:
            prompt = "%s: " % key
            entry = "%s: %s\n" % (key, raw_input(prompt))
            new_cred.append(entry)
        
        # give the user a chance to improvise
        entry = raw_input("")
        
        # additional chances for improvisation
        while entry is not ".":
            new_cred.append(entry + "\n")
            entry = raw_input("")
        
        new_cred = "".join(new_cred)
        if not self.use_agent:
            encrypted_cred = self.gpg.encrypt(new_cred, self.default_recipients, passphrase=self.passphrase)
        else:
            encrypted_cred = self.gpg.encrypt(new_cred, self.default_recipients)
        new_cred_file.write(str(encrypted_cred))
        return self.load_yaml(new_cred)

    def get_path(self, cred):
        return self.passwords + cred + self.extension

    def get(self, cred):
        path = self.get_path(cred)
        encrypted = self.__open(path, "rb")
        if not self.use_agent:
            decrypted = str(self.gpg.decrypt_file(encrypted, passphrase=self.passphrase))
        else:
            decrypted = str(self.gpg.decrypt_file(encrypted))

        if not decrypted:
            raise Exception("No Contents", "the file %s has no contents" % path)
        else:
            return self.load_yaml(decrypted)

    def load_yaml(self, data):
        try:
            data = yaml.load(data)
        except yaml.YAMLError as err:
            # surpress most of YAMLError to avoid sending a stacktrace with a password to stderr
            raise Exception(err.context, err.problem)
        else:
            return data

    def dump_schema(self):
        return yaml.dump(self.schema, default_flow_style=False)

def main():
    parser = argparse.ArgumentParser(description="Query passwords from GPG encrypted files.")
    parser.add_argument('-d', '--dump-schema', dest='dump_schema', action='store_true',
        help='Dump the credential schema loaded from the configuration.')
    parser.add_argument('-l', dest='list_keys', action='store_true',
        help='List the keys in a credential.')
    parser.add_argument('-s', '--save', dest='save_cred', action='store_true',
        help='Save a credential, prompting for details overwriting any existing cred file.')
    parser.add_argument('name', default=False, nargs="?",
        help="The name of the credential to look up.")
    parser.add_argument('fields', default=False, nargs="*",
        help="The name of the field or fields to retrieve. If no fields are specified, all fields are returned.")
    
    arg = parser.parse_args()
    
    try:
        creds = Creds()
        if arg.name and not arg.save_cred:
            cred = creds.get(arg.name)
        elif arg.save_cred:
            cred = creds.save(arg.name)
    except Exception as (errno, strerr):
        sys.stderr.write('%s: %s\n' % (errno, strerr))
        status = 1
    else:
        if arg.name:
            if arg.fields:
                for field in arg.fields:
                    print cred[field]
            else:
                # only list the available keys in the credential
                if arg.list_keys:
                    for field in cred:
                        print field
                else:
                    for field in cred:
                        print "%s: %s" % (field, cred[field])
        elif arg.dump_schema:
            print creds.dump_schema()
        status = 0
    
    return status

if __name__ == "__main__":
    sys.exit(main())
