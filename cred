#!/usr/bin/env python

import gnupg
import getpass
import os
import sys
import yaml

class Creds(object):
    def __init__(self, config="conf.yaml", verbose=False):
        config = self.load_yaml(self.__read(config, "r"))
        
        # copy all the config keys into self
        for attr in config:
            self.__dict__[attr] = config[attr]

        # check to see if there's actually an agent in the env
        self.agent = os.environ.get("GPG_AGENT_INFO", False)
        self.verbose = verbose

        # wanting to use an agent is cool, but if you don't have one...
        if self.use_agent and self.agent:
            self.gpg = gnupg.GPG(gnupghome=self.gpg_home, use_agent=self.use_agent, verbose=self.verbose)
        else:
            # whether this is the setting or the fallback, it's definitely False henceforth
            self.use_agent = False
            self.passphrase = getpass.getpass()
            self.gpg = gnupg.GPG(gnupghome=self.gpg_home, passphrase=self.passphrase, verbose=self.verbose)

    def __read(self, path, mode):
        try:
            stream = open(path, mode)
        except IOError:
            raise
        else:
            return stream
            
    def get(self, cred):
        encrypted = self.__read(cred, "rb")
        decrypted = str(self.gpg.decrypt_file(encrypted))

        if not decrypted:
            raise Exception("No Contents", "the file %s has no contents" % cred)
        else:
            try:
                credentials = yaml.load(decrypted)
            except yaml.YAMLError, err:
                # surpress most of YAMLError to avoid sending a stacktrace with a password to stderr
                raise Exception(err.context, err.problem)
            else:
                return credentials

    def load_yaml(self, data):
        try:
            data = yaml.load(data)
            return data
        except yaml.YAMLError:
            raise

def main():
    try:
        creds = Creds()
        cred = creds.get("asshats.org.yaml.asc")
    except Exception, (errno, strerr):
        sys.stderr.write('%s: %s\n' % (errno, strerr))
        status = 1
    else:
        print cred
        status = 0
    finally:
        return status

if __name__ == "__main__":
    sys.exit(main())
